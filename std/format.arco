
fn print(i int64) {
	if i < 0 {
		i = -i;
		print("-");
	}

	print(cast(uint64) i);
}

fn print(i uint64) {
	if i == 0 {
		print("0");
		return;
	}

	// TODO: Performance wise this can be improved just writing
	//       backwards into the buffer using pointer arithmetic.
	length int = 0;
	buffer char[21];

	v int = i;
	loop v > 0 {
		v = v / 10;
		length = length + 1;
	}

	scan int = length - 1;
	loop i > 0 {
		val int = (i % 10) + 48;
		buffer[scan] = cast(char) val;
		scan = scan - 1;
		i = i / 10;
	}

	print(buffer, length);
}

fn print(msg cstr, length int) {
	handle        void* = GetStdHandle(-11);
	bytes_written uint32;
	WriteFile(handle, msg, length, &bytes_written, null);
}

fn print(msg cstr) {
	print(msg, strlen(msg));
}

// TODO: Should be pass by const ref once supported.
fn print(msg String) {
	print(msg.buffer, msg.length);
}

// TODO: Functions are redundent because there is no support for
//       templating yet!

fn println(msg cstr) {
	print(msg, strlen(msg));
	print("\n", 1);
}

fn println(i int) {
	print(cast(int64) i);
	print("\n", 1);
}

fn println(i uint) {
	print(cast(uint64) i);
	print("\n", 1);
}

// TODO: Should be pass by const ref once supported.
fn println(msg String) {
	print(msg);
	print("\n", 1);
}

fn read(buffer char*, length int) int {
	handle               void* = GetStdHandle(-10);
	number_of_bytes_read uint32;
	ReadFile(handle, buffer, cast(uint32) length, &number_of_bytes_read, null);
	return cast(int) number_of_bytes_read;
}

fn read_line() String {
	buffer char[1024];
	amount_read int = read(buffer, buffer.length);
	// -2 because of \r\n is read when calling Windows ReadFile.
	return String{ buffer, amount_read - 2 };
}