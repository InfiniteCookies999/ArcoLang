
String struct {

	length int;
	buffer char*;

	fn ~String() {
		delete buffer;
		buffer = null;
		length = 0;
	}

	/*
	 * Defaults to having zero length.
	 */
	fn String() {
		
	}

	/*
	 * Creates a string from a null terminated
	 * character buffer.
	 */
	fn String(buffer cstr) {
		this.length = strlen(buffer);
		this.buffer = new char[length + 1]; // +1 for null terminator.
		memcpy(this.buffer, buffer, length + 1);
	}

	/*
	 * Creates a String from a character buffer and
	 * an explicit length. Because of the explicity
	 * defined length the buffer does not have to be
	 * null terminated.
	 *
	 * If the buffer is null terminated do not include
	 * the null termination in the length.
	 */
	fn String(buffer cstr, length int) {
		if length < 0 {
			panic("String length length < 0");
		}

		this.length = length;
		this.buffer = new char[length + 1]; // +1 for null terminator.
		memcpy(this.buffer, buffer, length);
		this.buffer[length] = '\0';
	}

	/*
	 * Creates a String from a character buffer and
	 * an explicit length. Because of the explicity
	 * defined length the buffer does not have to be
	 * null terminated.
	 *
	 * If the buffer is null terminated do not include
	 * the null termination in the length.
	 *
	 * @Param copy_buffer if true it allocates new memory
	 *                    and copies the buffer over otherwise
	 *                    the buffer is assumed to be already
	 *                    allocated and null terminated.
	 */
	fn String(buffer char*, length int, copy_buffer bool = true) {
		if length < 0 {
			panic("String length length < 0");
		}
		
		this.length = length;
		if copy_buffer {
			this.buffer = new char[length + 1]; // +1 for null terminator.
			memcpy(this.buffer, buffer, length);
			this.buffer[length] = '\0';
		} else {
			this.buffer = buffer;
		}
	}

	/*
	 * Copy constructor.
	 */
	fn copyobj String(string String*) {
		this.length = string.length;
		this.buffer = new char[length + 1]; // +1 for null terminator.
		memcpy(this.buffer, string.buffer, length);
		this.buffer[length] = '\0';
	}

	/*
	 * Parses the string into a signed an  integer
	 * for using base-10. All the characters in the
	 * string (excluding a leading + or -) must be digits
	 * or _ for number seperation.
	 *
	 * The number is expected to fit into a 32 bit integer.
	 *
	 * @return a parsed signed integer.
	 */
	fn parse_int() int {
		return parse_int32();
	}

	/*
	 * Parses the string into a signed 32 bit integer
	 * for using base-10. All the characters in the
	 * string (excluding a leading + or -) must be digits
	 * or _ for number seperation.
	 *
	 * @return a parsed signed integer.
	 */
	fn parse_int32() int32 {
		return parse_int32(10);
	}

	/*
	 * Parses the string into a signed 32 bit integer
	 * for the given base. All the characters in the
	 * string (excluding a leading + or -) must be digits
	 * or _ for number seperation.
	 *
	 * @param  base to be used during parsing.
	 * @return a parsed signed integer.
	 */
	fn parse_int32(base int) uint32 {
		// TODO: Provide proper error handling once supported!

		if empty() {
			panic("Parse errror: empty string");
		}

		if base < MIN_PARSE_BASE {
			panic("Parse error: base < PARSE_MIN_BASE");
		}

		if base > MAX_PARSE_BASE {
			panic("Parse error: base > PARSE_MAX_BASE");
		}

		is_neg := false;
		i := 0;
		if base == 16 && buffer[0] == '0' && buffer[1] == 'x' {
			i = 2;
		}
		uc bool = base >= 11 && base <= 16;
		

		first := buffer[i];
		if first < '0' {
			if first == '-' {
				is_neg = true;
			} else if first != '+' {
				panic("Parse error: Invalid start to characters");
			}

			if length == 1 {
				panic("Parse error: + or - by itself");
			}

			++i; // Move over the + or - character.
		}

		b int32 = cast(int32) base;
		result, prev_value int32;
		loop i < length {
			ch := buffer[i++];
			if ch == NUMBER_SEPERATOR {
				continue;
			}

			if uc {
				ch = tolower(ch);
			}

			digit int32 = cast(int32) to_digit_for_base(ch, base);
			if digit < 0 {
				panic("Parse error: character was not a digit");
			}

			prev_value = result;
			result     = result * b + digit;

			if result / b < prev_value {
				panic("Parse error: Numeric overflow");
			}
		}
		
		// TODO: Would be nice to replace with ternary operator.
		if is_neg {
			return -result;
		} else {
			return result;
		}
	}

	/*
	 * Parses the string into a boolean.
	 *
	 * Must either be "true" or "false".
	 */
	fn parse_bool() bool {
		// TODO: Provide proper error handling once supported!
		if empty() {
			panic("Parse error: empty string");
		}

		if equals("true", 4) {
			return true;
		} else if equals("false", 5) {
			return false;
		} else {
			panic("Parse error: expected true or false");
			return false;
		}
	}

	/*
	 * Parses the string into a character.
	 */
	fn parse_char() char {
		// TODO: Provide proper error handling once supported!

		if empty() {
			panic("Parse error: empty string");
		}
		if length != 1 {
			panic("Parse error: length > 1");
		}

		return buffer[0];
	}

	fn append(s String*) String* {
		return append(s.buffer, s.length);
	}

	fn append(s cstr) String* {
		return append(s, strlen(s));
	}

	fn append(s cstr, length int) String* {
		// TODO: should probably use capacities and grow by *2 when not enough space.

		new_length := this.length + length;
		new_buffer := new char[new_length + 1]; // +1 for null termination.

		memcpy(new_buffer, this.buffer, this.length);
		memcpy(new_buffer + this.length, s, length);
		
		delete this.buffer;
		this.buffer = new_buffer;
		this.length = new_length;
		this.buffer[this.length] = '\0';

		return this;
	}

	fn equals(s String*) bool {
		return equals(s.buffer, s.length);
	}

	fn equals(s cstr) bool {
		return equals(s, strlen(s));
	}

	fn equals(s cstr, s_length int) bool {
		if s_length != length {
			return false;
		}
		loop i := 0; i < length; i++ {
			if buffer[i] != s[i] {
				return false;
			}
		}
		return true;
	}

	fn empty() bool {
		return length == 0;
	}
}

/*
 * Converts a 64 bit unsigned integer to
 * a string containing the digits in base-10.
 */
fn to_string(i uint64) String {
	BUFFER_SIZE :: 21;
	buffer char[BUFFER_SIZE];

	ptr char* = chars_of_uint64(i, buffer + BUFFER_SIZE - 1, 10);
	length := cast(uint)(buffer + BUFFER_SIZE) - cast(uint)ptr;
	
	return String{ ptr, length };
}

/*
 * Converts a 64 bit signed integer to
 * a string containing the digits in base-10.
 */
fn to_string(i int64) String {
	BUFFER_SIZE :: 21 + 1;
	buffer char[BUFFER_SIZE];

	is_neg := i < 0;
	if is_neg {
		i = -i;
	}

	ptr char* = chars_of_uint64(i, buffer + BUFFER_SIZE - 1, 10);
	length := cast(uint)(buffer + BUFFER_SIZE) - cast(uint)ptr;

	if is_neg {
		--ptr;
		*ptr = '-';
		++length;
	}

	return String{ ptr, length };
}

fn to_string(i uint) String {
	return to_string(cast(uint64) i);
}

fn to_string(i int) String {
	return to_string(cast(int64) i);
}

fn to_string(b bool) String {
	// TODO: can be replaced with a ternary operator.
	if b {
		return String{ "true", 4 };
	} else {
		return String{ "false", 5 };
	}
}

fn to_string(c char) String {
	return String{ &c, 1 };
}
