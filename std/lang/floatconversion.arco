import math;

/*
 * Fills a buffer with the digits of the value. The format is such that
 * a decimal point is placed after the first digit and displays an exponent
 * if needed. Relies on the dragon4 algorithm to perform the floating
 * point conversion to characters.
 *
 * The returned chars buffer is null terminated.
 *
 * @param value     the value to convert to characters.
 * @param chars     the buffer to be filled with characters.
 * @param num_chars how long the resulting string is after conversion.
 */
fn chars_of_float64(value float64, chars char[30], num_chars int*) {

    bits      := bitcast(uint64) value;
    is_neg    := (bits >> 63) != 0;
    frac_bits := (bits & 0x000FFFFFFFFFFFFF);
    exp_bits  := cast(int64) (bits >> 52) & 0x7FF;

    if exp_bits == 0b11111111111 {
        if frac_bits == 0 {
            if is_neg {
                memcpy(chars, "-inf", 5);
                *num_chars = 4;
            } else {
                memcpy(chars, "inf", 4);
                *num_chars = 3;
            }
        } else {
            memcpy(chars, "nan", 4);
            *num_chars = 3;
        }
        return;
    }
    
    frac          uint64;
    exp           int;
    num_frac_bits int = 52;
    
    if exp_bits != 0 {
        frac = frac_bits | (1'u64 << 52);  // Adding the implicitely assumed 1 to the value.
        exp = cast(int) exp_bits - 1023;   // Removing the bias from the exponent.
    } else {
        // Check for zero case.
        if frac_bits == 0 {
            if is_neg {
                memcpy(chars, "-0.0", 5);
                *num_chars = 4;
            } else {
                memcpy(chars, "0.0", 4);
                *num_chars = 3;
            }
            return;
        }
        // value = (0.frac bits)_2 * 2^-1022
        // going to normalized by shifting off the leading zeros.
        num_leading_zeros := count_leading_zeros(frac_bits);
        // Got to account for the fact that the sign bit and exponent bits were stripped off
        // and are zeros.
        shift := num_leading_zeros - 11;
        frac = frac_bits << (cast(uint64) shift);
        // num_leading_zeros gets included because we just we just shifted the number by that amount.
        exp = -1022 - shift;
    }

    // Let us do the difficult work.
    buffer char[20] = ---;
    dec_exp, count, buf_offset int;
    dragon4(frac, exp, num_frac_bits, buffer, &dec_exp, &count, &buf_offset);

    *num_chars = fmt_dragon4_chars(is_neg, dec_exp, count, buf_offset, buffer, chars);
}

/*
 * Fills a buffer with the digits of the value. The format is such that
 * a decimal point is placed after the first digit and displays an exponent
 * if needed. Relies on the dragon4 algorithm to perform the floating
 * point conversion to characters.
 *
 * The returned chars buffer is null terminated.
 *
 * @param value     the value to convert to characters.
 * @param chars     the buffer to be filled with characters.
 * @param num_chars how long the resulting string is after conversion.
 */
fn chars_of_float32(value float32, chars char[30], num_chars int*) {

    bits      := bitcast(uint32) value;
    is_neg    := (bits >> 31) != 0;
    frac_bits := (bits & 0x007FFFFF);
    exp_bits  := cast(int32) (bits >> 23) & 0xFF;

    if exp_bits == 0b11111111 {
        if frac_bits == 0 {
            if is_neg {
                memcpy(chars, "-inf", 5);
                *num_chars = 4;
            } else {
                memcpy(chars, "inf", 4);
                *num_chars = 3;
            }
        } else {
            memcpy(chars, "nan", 4);
            *num_chars = 3;
        }
        return;
    }

    frac          uint64;
    exp           int;
    num_frac_bits int = 23;
    
    if exp_bits != 0 {
        frac = frac_bits | (1'u64 << 23);  // Adding the implicitely assumed 1 to the value.
        exp = cast(int) exp_bits - 127;   // Removing the bias from the exponent.
    } else {
        // Check for zero case.
        if frac_bits == 0 {
            if is_neg {
                memcpy(chars, "-0.0", 5);
                *num_chars = 4;
            } else {
                memcpy(chars, "0.0", 4);
                *num_chars = 3;
            }
            return;
        }
    
        // value = (0.frac bits)_2 * 2^-126
        // going to normalized by shifting off the leading zeros.
        num_leading_zeros := count_leading_zeros(frac_bits);
        // Got to account for the fact that the sign bit and exponent bits were stripped off
        // and are zeros.
        shift := num_leading_zeros - 8;
        frac = frac_bits << (cast(uint64) shift);
        // num_leading_zeros gets included because we just we just shifted the number by that amount.
        exp = -126 - shift;
    }

    // Let us do the difficult work.
    buffer char[20] = ---;
    dec_exp, count, buf_offset int;
    dragon4(frac, exp, num_frac_bits, buffer, &dec_exp, &count, &buf_offset);

    *num_chars = fmt_dragon4_chars(is_neg, dec_exp, count, buf_offset, buffer, chars);
}



/*
 * This is how many times 2^n can be divided by 10^m.
 *
 * Used to convert the insignificant bits where are in
 * powers of 2 to the equivalent amount in decimal.
 */
private INSIGNIFICANT_DIGITS_POW2_TO_DEC :: [
     0, 0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 3,
     4, 4, 4, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7,
     8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 11, 11, 11,
     12, 12, 12, 12, 13, 13, 13, 14, 14, 14,
     15, 15, 15, 15, 16, 16, 16, 17, 17, 17,
     18, 18, 18, 19
];

private POW10_UINT64_TABLE :: [uint64][
    1E0 , 1E1 , 1E2 , 1E3 , 1E4 , 1E5,
    1E6 , 1E7 , 1E8 , 1E9 , 1E10, 1E11,
    1E12, 1E13, 1E14, 1E15, 1E16, 1E17,
    1E18, 10000000000000000000 // Eh, semantic analysis probably catching because floats need space for exp/sign bit.
];

// ceil( log2(5^i) )
private POW5_BITS_TABLE :: [
  0,  3,  5,  7,  10, 12, 14, 17, 19, 21, 24, 26, 28,
  31, 33, 35, 38, 40, 42, 45, 47, 49, 52, 54, 56, 59, 61,
];

POW5_UINT64_TABLE :: [uint64][
    1,
    5,
    5*5,
    5*5*5,
    5*5*5*5,
    5*5*5*5*5,
    5*5*5*5*5*5,
    5*5*5*5*5*5*5,
    5*5*5*5*5*5*5*5,
    5*5*5*5*5*5*5*5*5,
    5*5*5*5*5*5*5*5*5*5,
    5*5*5*5*5*5*5*5*5*5*5,
    5*5*5*5*5*5*5*5*5*5*5*5,
    5*5*5*5*5*5*5*5*5*5*5*5*5,
    5*5*5*5*5*5*5*5*5*5*5*5*5*5,
    5*5*5*5*5*5*5*5*5*5*5*5*5*5*5,
    5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5,
    5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5,
    5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5,
    5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5,
    5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5,
    5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5,
    5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5,
    5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5,
    5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5,
    5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5,
    5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5,
    5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5,
];

POW5_UINT32_TABLE :: [uint32][
    1,
    5,
    5*5,
    5*5*5,
    5*5*5*5,
    5*5*5*5*5,
    5*5*5*5*5*5,
    5*5*5*5*5*5*5,
    5*5*5*5*5*5*5*5,
    5*5*5*5*5*5*5*5*5,
    5*5*5*5*5*5*5*5*5*5,
    5*5*5*5*5*5*5*5*5*5*5,
    5*5*5*5*5*5*5*5*5*5*5*5,
];

/*
 * A Cache of power 5 big integers so they do not have
 * to be continually recalculated.
 */
private POW5_CACHE BigIntFD[100];
private pow5_cache_initialized := false;

private fn initialize_pow5_cache() {
    pow5_cache_initialized = true;

    loop i : 0..<POW5_UINT32_TABLE.length {
        pow5_bigint BigIntFD* = &POW5_CACHE[i];
        pow5_bigint.blocks = new uint32[1];
        pow5_bigint.length = 1;
        *pow5_bigint.blocks = POW5_UINT32_TABLE[i];
    }

    prev_pow5 BigIntFD* = &POW5_CACHE[POW5_UINT32_TABLE.length - 1]; 
    loop i : POW5_UINT32_TABLE.length ..< POW5_CACHE.length {
        POW5_CACHE[i] = prev_pow5.multiply(5);
        prev_pow5 = &POW5_CACHE[i];
    }
}

/*
 * NOTE: Although according to "How to print floating-point numbers accurately" by Guy L. Steele Jr. and Jon L White
 * all calculations can be performed with only 32 words we use a variable amount since this will be reused when calculating
 * parsed floating point values which requires a variable amount.
 */
private BigIntFD struct {

    blocks uint32*;
    length int; // How many blocks.
    
    ~BigIntFD() {
        delete blocks;
        blocks = null;
    }

    BigIntFD() {}

    BigIntFD copyobj(o BigIntFD*) {
        this.length = o.length;
        this.blocks = new uint32[o.length];
        memcpy(this.blocks, o.blocks, o.length * sizeof(uint32));
    }

    BigIntFD(block1 uint32, block2 uint32, offset int) {
        if block1 == 0 && block2 == 0 {
            // Shifting 0 by offset is still just 0.
            blocks = null;
            length = 0;
            return;
        } 
    
        blocks = new uint32[offset + 2];
        memset(blocks, 0, offset * sizeof(uint32));
        blocks[offset]   = block1;
        blocks[offset+1] = block2;
        length = offset + 2;
        if (block2 == 0) {
            // Last block is zero, trim.
            --length;
        }
    }

    BigIntFD(block1 uint32, block2 uint32, block3 uint32, offset int) {
        blocks = new uint32[offset + 3];
        memset(blocks, 0, offset * sizeof(uint32));
        blocks[offset]   = block1;
        blocks[offset+1] = block2;
        blocks[offset+2] = block3;
        length = offset + 3;
        trim_leading_zeros();
    }

    fn multiply(constant uint32) BigIntFD {
        if this.length == 0  return BigIntFD{}; // Return zero

        result BigIntFD;
        result.blocks = new uint32[this.length + 1];

        value uint64 = cast(uint64) constant;
        ptr uint32* = blocks;
        end uint32* = blocks + length;
        res_ptr uint32* = result.blocks; 
        carry uint64 = 0;
        loop ptr != end {
            product uint64 = cast(uint64)*ptr * value + carry;
            *res_ptr = cast(uint32) product;
            carry = product >> 32;
            ++ptr;
            ++res_ptr;
        }

        if carry != 0 {
            *res_ptr = cast(uint32) carry;
            result.length = this.length + 1;
        } else {
            result.length = this.length;
        }
        return result;
    }

    fn multiply(constant1 uint32, constant2 uint32) BigIntFD {
        result BigIntFD;
        result.blocks = new uint32[this.length + 2];

        value uint64 = cast(uint32) constant1;
        ptr     uint32* = blocks;
        end     uint32* = blocks + length;
        res_ptr uint32* = result.blocks; 
        carry uint64 = 0;
        loop ptr != end {
            product uint64 = value * cast(uint64) *ptr + carry;
            *res_ptr = cast(uint32) product;
            carry = product >> 32;
            ++ptr;
            ++res_ptr;
        }
        *res_ptr = cast(uint32) carry;
        value = cast(uint64) constant2;
        carry = 0;
        ptr = blocks;
        res_ptr = result.blocks + 1;
        loop ptr != end {
            product uint64 = cast(uint64)*res_ptr + value * cast(uint64)*ptr + carry;
            *res_ptr = cast(uint32) product;
            carry = product >> 32;
            ++ptr;
            ++res_ptr;
        }
    
        if carry != 0 {
            *res_ptr = cast(uint32) carry;
            result.length = this.length + 2;
        } else {
            result.length = this.length + 1;
        }

        return result;
    }

    fn multiply(o BigIntFD^) BigIntFD {
        if this.length == 0  return BigIntFD{}; // Return zero
        if o.length == 0     return BigIntFD{}; // Return zero
        if this.length == 1
            return o.multiply(blocks[0]);
        if o.length == 1
            return this.multiply(o.blocks[0]);

        result BigIntFD;
        // Need to clear the result data because it is being used in
        // the multiplication loop and it initialially has random data.
        result.length = this.length + o.length;
        result.blocks = new uint32[result.length];
        memset(result.blocks, 0, result.length * sizeof(uint32));

        out_ptr uint32* = this.blocks;
        out_end uint32* = this.blocks + length;
        res_ptr uint32* = result.blocks;
        loop out_ptr != out_end {
            multiplier uint64 = cast(uint64) *out_ptr;
            product    uint64 = 0;
            inr_ptr     uint32* = o.blocks;
            inr_end     uint32* = o.blocks + o.length;
            res_inr_ptr uint32* = res_ptr;
            loop inr_ptr != inr_end {
                product += cast(uint64)*res_inr_ptr + multiplier * cast(uint64)*inr_ptr;
                *res_inr_ptr = cast(uint32) product;
                product >>= 32; // Get carry.
                ++inr_ptr;
                ++res_inr_ptr;
            }
            *res_inr_ptr = cast(uint32) product;

            ++out_ptr;
            ++res_ptr;
        }

        if result.blocks[result.length - 1] == 0 {
            --result.length;
        }

        return result;
    }

    fn left_shift(shift int) BigIntFD {
        // TODO: if offsets are ever included it may be
        // possible to improve performance here by
        // instead of creating new allocation just reusing
        // the old data and setting the offset to the block
        // shift.
        if shift == 0 || this.length == 0 {
            return *this;
        }

        sft_block_idx int    = shift >> 5;
        sft_mod_idx   uint32 = cast(uint32) (shift & 31);
        result BigIntFD;
    
        if sft_mod_idx == 0 {
            // Block aligned.
            result.length = this.length + sft_block_idx;
            result.blocks = new uint32[result.length];

            // Zero low blocks.
            memset(result.blocks, 0, sft_block_idx * sizeof(uint32));
            // Copy blocks into higher indexes.
            memcpy(result.blocks + sft_block_idx,
                       this.blocks,
                       this.length * sizeof(uint32));
        } else {
            // Slide the block we are working with by the shift
            // then append the high bits of the previous block.

            result.blocks = new uint32[length + sft_block_idx + 1];

            fm_ptr uint32* = blocks + length - 1;
            to_ptr uint32* = result.blocks + length + sft_block_idx;

            // How far to shift to extract the previous block's high bits which become the block we
            // are working withs low bits.
            low_bits_shift uint32 = 32 - sft_mod_idx;

            high_bits uint32 = 0;
            low_bits  uint32 = *fm_ptr >> low_bits_shift;
            loop fm_ptr > blocks {
                *to_ptr = high_bits | low_bits;
                high_bits = *fm_ptr << sft_mod_idx;

                --fm_ptr;
                --to_ptr;
            
                low_bits = *fm_ptr >> low_bits_shift;
            }

            // final block which is also the lowest block only
            // has high bits because its lower bits were shifted.
            *to_ptr = high_bits | low_bits;
            *(to_ptr-1) = *fm_ptr << sft_mod_idx;

            // Zero the low blocks.
            memset(result.blocks, 0, sft_block_idx * sizeof(uint32));

            result_length int = length + sft_block_idx + 1;
            if (result.blocks[result_length - 1] == 0) {
                --result_length;
            }

            result.length = result_length;
        }

        return result;
    }

    /*
     * Mutates this struct by multiplying it by 10.
     */
    fn multiply_this_by10() {

        carry uint64;
        ptr uint32* = blocks;
        end uint32* = blocks + length;
        loop ptr != end {
            product uint64 = cast(uint64) *ptr * 10'u64 + carry;
            *ptr = cast(uint32) product;
            carry = product >> 32;
            ++ptr;
        }
        
        if carry != 0 {
            new_blocks uint32* = new uint32[length + 1];
            memcpy(new_blocks, blocks, length * sizeof(uint32));
            delete blocks;
            blocks = new_blocks;
            blocks[length] = cast(uint32) carry;
            ++length;
        } else {
            trim_leading_zeros();
        }
    }

    /*
     * This function mutates the struct. 
     *
     * Returns   this / divisor  and computes:
     *   10 * (this mod divisor)
     */
    fn divide_and_multi10_with_remainder(divisor BigIntFD^) uint32 {
        if this.length < divisor.length {
            multiply_this_by10();
            return 0;
        } else if this.length > divisor.length {
            panic("!!! divisor was smaller !!!");
        }
        // Estimate by computing the last block division.
        quotient uint64 = cast(uint64)blocks[this.length - 1] / cast(uint64)divisor.blocks[divisor.length - 1];
        
        // This check can be used to ensure the estimate was right or wrong:
        // this/divisor = quotient
        // this = quotient*divisor
        // this - quotient*divisor = 0
        difference int64 = 0;
        if quotient != 0 {
            
            div_ptr uint32* = divisor.blocks;
            div_end uint32* = divisor.blocks + divisor.length;
            ptr     uint32* = this.blocks;
            
            loop div_ptr != div_end {
                difference += cast(uint64)*ptr - quotient * cast(uint64)*div_ptr;
                *ptr = cast(uint32) difference;
                difference >>= 32;
                ++ptr;
                ++div_ptr;
            }
        }
        
        if difference != 0 {
            // Well no actually it was off. Luckily this should rarely happen.
            
            sum uint64 = 0;
            loop sum == 0 {
                loop i : 0..<length {
                    sum += (cast(uint64) blocks[i]) + (cast(uint64) divisor.blocks[i]);
                    blocks[i] = cast(uint32) sum;
                    sum >>= 32;
                }

                quotient -= 1;
            }
        }
        
        multiply_this_by10();
        return cast(uint32) quotient;
    }

    /*
     * Compares this BigIntFD to o BigIntFD.
     *
     * If this > o returns +1.
     * If this < o returns -1.
     * If this == o returns 0.
     */
    fn compare(o BigIntFD^) int {
        if this.length > o.length {
            return +1;
        } else if this.length < o.length {
            return -1;
        }
        
        // Traverse in reverse order because want to compare
        // highest significant blocks first.
        loop i := this.length - 1; i >= 0; i-- {
            lhsv := this.blocks[i];
            rhsv := o.blocks[i];
            if lhsv != rhsv {
                return lhsv < rhsv ? -1 : +1;
            }
        }
    
        // Exact match.
        return 0;
    }

    /*
     * Compares this BigIntFD to x + y.
     *
     * If this > x+y returns +1.
     * If this < x+y returns -1.
     * If this == x+y returns 0.
     */
    fn add_and_compare(x BigIntFD^, y BigIntFD^) int {
        
        // Find the smaller one.
        large BigIntFD* = ---;
        small BigIntFD* = ---;
        xl := x.length;
        yl := y.length;
        if xl >= yl {
            large = x;
            small = y;
        } else {
            large = y;
            small = x;
        }
        if large.length == 0 {
            return this.length == 0 ? 0 : 1;
        }
        if small.length == 0 {
            return compare(large);
        }
        if large.length > this.length {
            return -1;
        }
        if large.length + 1 < this.length {
            return +1;
        }
        
        // TODO: java does further optimization here.
        
        return compare(x.add(y));
    }

    fn add(o BigIntFD^) BigIntFD {
        
        large BigIntFD* = ---;
        small BigIntFD* = ---;
        if this.length < o.length {
            large = o;
            small = this;
        } else {
            large = this;
            small = o;
        }
        
        result BigIntFD;
        result.blocks = new uint32[large.length + 1];
        
        res_ptr   uint32* = result.blocks;
        small_ptr uint32* = small.blocks;
        small_end uint32* = small_ptr + small.length;
        large_ptr uint32* = large.blocks;
        large_end uint32* = large_ptr + large.length;
        carry uint64 = 0;
        loop small_ptr != small_end {
            sum uint64 = cast(uint64)*large_ptr + cast(uint64)*small_ptr + carry;
            carry = sum >> 32;
            *res_ptr = cast(uint32) sum;
            ++small_ptr;
            ++large_ptr;
            ++res_ptr;
        }
        
        loop large_ptr != large_end {
            sum uint64 = cast(uint64)*large_ptr + carry;
            carry = sum >> 32;
            *res_ptr = cast(uint32) sum;
            ++large_ptr;
            ++res_ptr;
        }
        
        if carry != 0 {
            *res_ptr = 1;
            result.length = large.length + 1;
        } else {
            result.length = large.length;
        }
        
        return result;
    }

    fn trim_leading_zeros() {
        ptr uint32* = blocks + length - 1;
        loop ptr >= blocks {
            if *ptr == 0  --length;
            else break;
            --ptr;
        }
    }

    fn get_normalization_bias() int {
        zeros int = count_leading_zeros(blocks[length - 1]);
        if zeros < 4 {
            return 28 + zeros;
        } else {
            return zeros - 4;
        }
    }
}

private fn make_bigint_from_pow5(pow5 int) BigIntFD {
    if pow5 < POW5_CACHE.length {
        return POW5_CACHE[pow5];
    }

    // 5^pow5 = 5^(q+r) = 5^q * 5^r
    // divide the power in 2.
    // q = pow5/2, r = pow5 - q
    q := pow5 >> 1;
    r := pow5 - q;

    bq BigIntFD = make_bigint_from_pow5(q);
    if (r < POW5_UINT32_TABLE.length) {
        return bq.multiply(POW5_UINT32_TABLE[r]);
    } else {
        br BigIntFD = make_bigint_from_pow5(r);
        return bq.multiply(br);
    }
}

/*
 * Constructs a big integer with value 2^pow2.
 */
private fn make_bigint_from_pow2(pow2 int) BigIntFD {
    i BigIntFD;
    i.length = (pow2 >> 5) + 1; // divide by 32.
    i.blocks = new uint32[i.length];
    sft_mod_idx uint32 = cast(uint32) (pow2 & 31);
    // Zero low blocks.
    memset(i.blocks, 0, (i.length - 1) * sizeof(uint32));
    i.blocks[i.length-1] = 1'u32 << sft_mod_idx;
    return i;
}

/*
 * Constructs a big integer with value = 2^pow2 * 5^pow5.
 */
private fn make_bigint_from_pow2pow5(pow2 int, pow5 int) BigIntFD {
    if pow5 != 0 {
        if pow2 == 0 {
            return make_bigint_from_pow5(pow5);
        } else {
            return make_bigint_from_pow5(pow5).left_shift(pow2);
        }
    } else {
        return make_bigint_from_pow2(pow2);
    }
}

/*
 * Constructs a big integer with value = sigf * 2^pow2 * 5^pow5.
 */
fn make_bigint_from_sigf_pow2pow5(sigf uint64, pow2 int, pow5 int) BigIntFD {
    block1 uint32 = cast(uint32) sigf;
    block2 uint32 = cast(uint32) (sigf >> 32);
    sft_block_idx int = pow2 >> 5;
    sft_mod_idx uint32 = cast(uint32) (pow2 & 31);

    if (pow5 != 0) {
        if (pow5 < POW5_UINT32_TABLE.length) {
            pow5_val uint64 = cast(uint64) POW5_UINT32_TABLE[pow5];
            
            product  uint64 = pow5_val * cast(uint64) block1;
            carry uint64 = product >> 32;
            block1 = cast(uint32) product;

            product = pow5_val * cast(uint64)block2 + carry;
            block2 = cast(uint32) product;
            
            block3 uint32 = cast(uint32) (product >> 32);
            if (sft_mod_idx == 0) {
                // Shift is block aligned so can optimize by
                // just moving the values over the correct number
                // of blocks.
                return BigIntFD{block1, block2, block3, sft_block_idx};
            } else {
                result BigIntFD;
                result.blocks = new uint32[sft_block_idx + 4];
                result.blocks[sft_block_idx+0] = block1 << sft_mod_idx;
                result.blocks[sft_block_idx+1] = (block2 << sft_mod_idx) | (block1 >> (32 - sft_mod_idx));
                result.blocks[sft_block_idx+2] = (block3 << sft_mod_idx) | (block2 >> (32 - sft_mod_idx));
                result.blocks[sft_block_idx+3] = block3 >> (32 - sft_mod_idx);
                result.length = sft_block_idx + 4;
                // Zero lower shifted blocks.
                memset(result.blocks, 0, sft_block_idx * sizeof(uint32));
                // Trim the leading zeros.
                result.trim_leading_zeros();
                return result;
            }
        } else {
            pow5_bigint BigIntFD = make_bigint_from_pow5(pow5);
            if (block2 == 0) {
                pow5_bigint = pow5_bigint.multiply(block1);
            } else {
                pow5_bigint = pow5_bigint.multiply(block1, block2);
            }

            return pow5_bigint.left_shift(pow2);
        }
    } else if (pow2 != 0) {
        if (sft_mod_idx == 0) {
            // Shift is block aligned so can optimize by
            // just moving the values over the correct number
            // of blocks.
            return BigIntFD{block1, block2, sft_block_idx};
        } else {
            return BigIntFD{
                block1 << sft_mod_idx,
                (block2 << sft_mod_idx) | (block1 >> (32 - sft_mod_idx)),
                block2 >> (32 - sft_mod_idx),
                sft_block_idx
            };
        }
    } else {
        return BigIntFD{block1, block2, 0};
    }
}



/* 
 * This function estimates the index of the highest significant digit in
 * base-10.
 *
 * Ex.  '125.5'     would return 2.
 *
 * Want to calculate  floor(log10(value))
 * floor(log10(value)) = floor(log2(value) / log2(10))
 *                     = floor(log2(value) * log10(2))
 *                     = floor( log2(frac * 2^e2) * log10(2) )
 *                     = floor( (log2(frac) + e2) * log10(2) )
 *
 * highest bit index of frac = floor(log2(frac)) = hbi
 *
 * Estimate:
 *    floor(log10(value)) <= ceil( floor( (hbi + e2) * log10(2) ) - 0.69 ) <= floor(log10(value)) + 1
 *
 */ 
private fn estimate_highest_sigidx_dec(hbi int, e2 int) int {
    log10_2 :: 0.30102999566398119521373889472449;
    //return cast(int) (math.ceil( (hbi + e2) * log10_2 - 0.69));
    return cast(int) (math.ceil( (hbi + e2) * log10_2 - 0.176091259));//0.176091259
}

private fn dragon4_roundup(buffer char[20], buf_off int, count int, dec_exp int*) {
    i := buf_off + count - 1;
    last char = buffer[i];
    if last == '9' { // Rounding up when ending in 9 means work must be done.
        // keep replacing 9s with zeros
        loop last == '9' && i > buf_off {
            buffer[i] = '0';
            last = buffer[--i];
        }
        if last == '9' {
            *dec_exp++;
            buffer[buf_off] = '1';
            return;
        }
    }
    buffer[i] = cast(char) (last + 1);
}

/*
 * All value representations passed to this function must be
 * in the form:
 *
 * value = frac * 2^(exp - num_frac_bits)
 *
 * where value is the float value in decimal.
 *
 * @param dec_exp the computed exponent in base-10.
 * @param count   the length of the buffer digits.
 * @param buf_off the starting offset into the buffer since digits
  *               may be backwards.
 */
fn dragon4(frac uint64, exp int, num_frac_bits int, buffer char[20], dec_exp int*, count int*, buf_off int*) {
    
    // TODO: Should the user have an option to not initialize the cache? Or initialize early?
    if !pow5_cache_initialized {
        initialize_pow5_cache();
    }

    // Value representation (in decimal):
    // 
    //  value = frac * 2^(exp - num_frac_bits)
    //
    // NOTE: Since frac is passed in as an integer it may seem
    //       confusing as to where the fractional part of the
    //       floating value went. It went into the 2^-num_frac_bits
    //       since 2^num_frac_bits is what the fraction bits would
    //       be multiplied by in order remove the fractional part from frac.
    //
    //    Ex.  value = (1.frac bits)_2 * 2^((exp bits)_2 - 1023)
    //               = (1.frac bits)_2 * 2^exp
    //               = (1 + frac bits)_2 * 2^-num_frac_bits * 2^exp
    //               = frac * 2^-num_frac_bits * 2^exp
    //               = frac * 2^(exp - num_frac_bits)
    
    
    // Pulling out 2^trailing_zeros since they are insignificant bits.
    //   (1.0101110000)_2
    //            ^^^^
    //            Do not care about these bits.
    //
    //  value = shifted_frac * 2^(exp - num_frac_bits + trailing_zeros)
    trailing_zeros := count_trailing_zeros(frac);
    shifted_frac   := frac >> cast(uint64) trailing_zeros;

    // First we check to see if it is just an integer and can be done
    // with 64 bits. If so we choose that option first.
    //
    // value = shifted_frac * 2^adj_expr
    adj_exp := exp - num_frac_bits + trailing_zeros;
    sig_frac_bits := num_frac_bits + 1 - trailing_zeros; // +1 because the number is normalized so the 1 is significant.

    if adj_exp >= 0 {

        // Let us determine how many bits are needed if we are to create
        // an integer out of this.
        //
        bit_count := sig_frac_bits + adj_exp;

        if bit_count < 64 { // TODO: Shouldn't this be <= 64?
            // Awesome, we can just compute an integer representation of the floating point!
            v uint64 = shifted_frac * (1'u64 << adj_exp);
        
            // Even though v is an integer representation it might still have bits we do not care
            // about because they are insignificant. so go to deal with them here.
            //
            // TODO: I have absolutely zero clue why the -2 is needed here.
            insig_bits := exp - num_frac_bits - 2;
            if insig_bits >= 4 { // >= 4 because below that it just ends up being zero.
                // Okay there are insignicant digits in base-10 to be taken care of.
                insig_digits := INSIGNIFICANT_DIGITS_POW2_TO_DEC[insig_bits];
                pow10        := POW10_UINT64_TABLE[insig_digits];
                rem := v % pow10;
                v /= pow10;
                *dec_exp += insig_digits; // Still need to know about them in the form of powers.
                if rem >= (pow10>>1) {
                    // round up since we are discarding.
                    ++v;
                }
            }
            
            // Cannot just call chars_of_uint64 because this has to deal with the leading
            // zeros since the algorithm is not meant to present insignificant digit information
            // to the user.
            //
            digit uint64 = v % 10;
            v /= 10;
            i := buffer.length - 1; // Because the algorithm has to work backwards.
            // consume trailing zeros.
            loop digit == 0 {
                digit = v % 10;
                v /= 10;
                ++(*dec_exp); // Still need to know about them even though they are insignificant.
            }
            // Okay let's deal with the signficant bits.
            loop v != 0 {
                buffer[i--] = cast(char) (digit + '0');
                digit = v % 10;
                v /= 10;
                ++(*dec_exp);
            }
            buffer[i] = cast(char) (digit + '0');
            *count   = buffer.length - i;
            *buf_off = i;

            return;
        } // TODO: Could probably optimize here by computing big integers for non-fractional values.
    }
    
    e2 := exp - num_frac_bits;
    hbi := num_frac_bits + 1; // Calculating the highest 1 bit index.
    
    // TODO: We really should fix the estimate function. It ends up being off rather
    //       frequently.
    *dec_exp = estimate_highest_sigidx_dec(hbi, e2);
    
    // Explaination for what form we are trying to get
    // things in.
    //
    // We have to avoid any floating point arithmetic so
    // everything must be integers. To actually calculate
    // the digits we have to divide the value by 10^dec_exp
    // so that the number is normalized in base-10.
    //
    // This is represented as:   R / S.
    // R / S = value / (10^dec_exp)
    //       = (frac * 2^(exp - num_frac_bits)) / (10^dec_exp)
    //
    // 10^dec_exp and 2^(exp - num_frac_bits) will belong to either the numerator
    // or denominator depending on the sign of the exponent of
    // both. With that in mind here I simply rearrange terms
    // into a form that is easy to work with even if in code they
    // they are shifted around a bit.
    //
    // (frac * 2^(exp - num_frac_bits)) / (10^dec_exp) = frac / (2^(num_frac_bits - exp) * 10^dec_exp)
    //
    // MarginLow formula derivation (assuming equal margins):
    // value - (1/2)*MarginLow < 0  ->  frac*2^(exp - num_frac_bits) - (1/2)*2^(exp - num_frac_bits) < 0
    //                              ->  2*frac*2^(exp - num_frac_bits) - 2^(exp - num_frac_bits) < 0
    //                              ->  2*frac*2^(exp - num_frac_bits) < 2^(exp - num_frac_bits)
    //                              ->  2*frac < 1
    //                              ->  R < M     (this is what low variable is set to)
    

    // General idea:
    // if we just store the 2^trailing_zeros in R2
    // and in M2 then when we pull out common factors.
    // if M2 becomes less than zero we can just scale
    // back up.
    
    // If dec_exp < 0 then need to multiply
    // the numerator by 10^-dec_exp because
    // we cannot divide the deonominator without
    // loss of information.

    R5 int = math.max(0, -(*dec_exp));
    R2 int = R5 + trailing_zeros + math.max(0, +e2);
    
    // Reverse case where 10^dec_exp can
    // belong in the denominator.
    S5 int = math.max(0, +(*dec_exp));
    S2 int = S5 + math.max(0, -e2);
    
    M2 int = R2 - trailing_zeros - 1;
    // Still need a M5 in case dec_exp < 0.
    M5 int = R5;

    // factor out powers of 2.
    commom_pow2_factor := math.min(R2, S2);
    R2 -= commom_pow2_factor;
    S2 -= commom_pow2_factor;
    M2 -= commom_pow2_factor;

    // TODO: this is meant to properly correct for uneven margins
    if sig_frac_bits == 1 {
        M2 -= 1;
    }
    
    if M2 < 0 {
        // Scaled M2 down too far!
        // Must scale the other values
        // up!
        R2 -= M2;
        S2 -= M2; // Must scale up denominator as well to keep the fraction.
        M2 = 0;
    }

    /*println("R2: %s", R2);
    println("R5: %s", R5);

    println("S2: %s", S2);
    println("S5: %s", S5);
    
    println("M2: %s", M2);
    println("M5: %s", M5);*/

    // Dealing the bit count calculations to see if we can do the calculations within 64 bits.
    S10_bits := S2 + 1;
    if S5+1 < POW5_BITS_TABLE.length {
        S10_bits += POW5_BITS_TABLE[S5+1];
    } else {
        S10_bits += 100; // just add a large enough number s.t. it does not fit 64 bits.
    }
    R_bits := R2 + sig_frac_bits;
    if R5 < POW5_BITS_TABLE.length {
        R_bits += POW5_BITS_TABLE[R5];
    } else {
        R_bits += 100; // just add a large enough number s.t. it does not fit 64 bits.
    }

    low, high bool;
    least_sig_digit_diff int64;
    if S10_bits < 64 && R_bits < 64 {
        // We are safe to use 64 bit arithmetic
        // rather than relying on big integers.
        
        R uint64 = (shifted_frac * POW5_UINT64_TABLE[R5]) << R2;
        S uint64 = POW5_UINT64_TABLE[S5] << S2;
        M uint64 = POW5_UINT64_TABLE[M5] << M2;
        
        S10 uint64 = S*10;

        // Preliminary check for if the power estimation was
        // wrong!
        U uint64 = R / S;
        R = 10 * ( R % S );
        M *= 10;
        low  = R < M;
        high = R + M > S10;
        
        if U == 0 && !high {
            // The estimation was off by 1
            --(*dec_exp);
        } else {
            buffer[*count++] = cast(char) (U + '0');
        }

        // Calculate the rest of the digits.
        if *dec_exp < -3 || *dec_exp >= 8 {
            high = false;
            low = false;
        }
        loop !low && !high {
            
            U = R / S;
            buffer[(*count)++] = cast(char) (U + '0');
            
            R = 10 * ( R % S );
            M *= 10;
            
            if M > 0 {
                low  = R < M;
                high = R + M > S10;
            } else {
                low  = true;
                high = true;
            }

            least_sig_digit_diff = (R<<1) - S10;
        }
    } else {
        // Well this sucks we have to use big integers!

        S BigIntFD = make_bigint_from_pow2pow5(S2, S5);
        shift_bias := S.get_normalization_bias(); // Is this even needed? Java uses a normalization bias and says it improves the divisor.
        S = S.left_shift(shift_bias); // TODO: optimization: use a mutating left_shift instead.
        
        S10 BigIntFD = make_bigint_from_pow2pow5(S2 + shift_bias + 1, S5 + 1);
        
        R BigIntFD = make_bigint_from_sigf_pow2pow5(shifted_frac, R2 + shift_bias, R5);
        // +1 here because need to multiply by 10 for first comparison.
        M BigIntFD = make_bigint_from_pow2pow5(M2 + shift_bias + 1, M5 + 1);
        
        U uint32 = R.divide_and_multi10_with_remainder(S);
        
        low  = R.compare(M) < 0;
        high = S10.add_and_compare(R, M) <= 0;

        // Preliminary check for if the power estimation was
        // wrong!
        if U == 0 && !high {
            // The estimation was off by 1
            --(*dec_exp);
        } else {
            buffer[*count++] = cast(char) (U + '0');
        }

        if *dec_exp < -3 || *dec_exp >= 8 {
            high = false;
            low = false;
        }
        loop !low && !high {
        
            U = R.divide_and_multi10_with_remainder(S);
            buffer[*count++] = cast(char) (U + '0');
            
            M.multiply_this_by10();

            low  = R.compare(M) < 0;
            high = S10.add_and_compare(R, M) <= 0;
            
        }

        if high && low {
            R = R.left_shift(1); // TODO: optimization: use a mutating left_shift instead.
            least_sig_digit_diff = cast(int64) R.compare(S10);
        } else {
            least_sig_digit_diff = 0;
        }
    }


    if high {
        if low {
            if least_sig_digit_diff == 0 {
                // its a tie so roundup if odd.
                if (buffer[*count + *buf_off - 1]&1) != 0 {
                    dragon4_roundup(buffer, *count, *buf_off, dec_exp);
                }
            } else if least_sig_digit_diff > 0 {
                dragon4_roundup(buffer, *count, *buf_off, dec_exp);
            }
        } else {
            dragon4_roundup(buffer, *count, *buf_off, dec_exp);
        }
    }
}

fn fmt_dragon4_chars(is_neg     bool,
                     dec_exp    int,
                     count      int,
                     buf_offset int,
                     buffer     char[20],
                     chars      char[30]) int {
    
    idx := 0;
    if is_neg {
        chars[idx++] = '-';
    }

    ++dec_exp;
    if dec_exp > 0 && dec_exp < 8 {
        l int = math.min(count, dec_exp); // get values before decimal point.
        memcpy(chars+idx, buffer+buf_offset, l);
        idx += l;
        if l < dec_exp { // no fraction case.
            l = dec_exp - l;
            // already formatted with leading whole digits.
            memset(chars+idx, '0', l); // Ex.  5000
            idx += l;
            chars[idx++] = '.';
            chars[idx++] = '0';
        } else {
            chars[idx++] = '.';
            if l < count { // fraction digits
                l2 int = count - l;
                memcpy(chars+idx, buffer+buf_offset+l, l2);
                idx += l2;
            } else { // no fraction digits but still want to show a zero.
                chars[idx++] = '0';
            }
        }
    } else if dec_exp <= 0 && dec_exp > -3 {
        chars[idx++] = '0';
        chars[idx++] = '.';
        if dec_exp != 0 {
            memset(chars+idx, '0', -dec_exp);
            idx += -dec_exp;
        }
        memcpy(chars+idx, buffer+buf_offset, count);
        idx += count;
    } else { // Ex.  firstDigit.fracDigitsE(+|-)exponent
        chars[idx++] = buffer[buf_offset];
        chars[idx++] = '.';
        if count > 1 {
            memcpy(chars+idx, buffer+buf_offset+1, count-1);
            idx += count-1;
        } else {
            chars[idx++] = '0';
        }
        chars[idx++] = 'E';
        e int;
        if dec_exp <= 0 {
            chars[idx++] = '-';
            e = -dec_exp + 1;
        } else {
            e = dec_exp - 1;
        }
        // Exponent can at most have 3 digits.
        if e <= 9 {
            chars[idx++] = cast(char) (e + '0');
        } else if e <= 99 {
            chars[idx++] = cast(char) (e / 10 + '0');
            chars[idx++] = cast(char) (e % 10 + '0');
        } else {
            chars[idx++] = cast(char) (e / 100 + '0');
            e %= 100;
            chars[idx++] = cast(char) (e / 10 + '0');
            chars[idx++] = cast(char) (e % 10 + '0');
        }
    }

    chars[idx] = '\0'; // Null termination.
    return idx;
}
