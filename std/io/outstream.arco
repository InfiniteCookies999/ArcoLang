import reflect.Any;
import reflect.Type;
import reflect.TypeId;

/**
 * An output stream for writing to files, sockets, or
 * any streamable handle that is writeable.
 */
OutStream struct {
    
    private handle Writeable*;

    OutStream(handle Writeable*)
        : handle(handle) {
    }

    fn write_buffer(msg cstr, length int) {
        handle.write_buffer(msg, length);
    }

    fn write(msg cstr) {
        write_buffer(msg, strlen(msg));
    }

    fn write(b bool) {
        if b {
            write("true");
        } else {
            write("false");
        }
    }

    fn write(c char) {
        write_buffer(&c, 1);
    }

    fn write(i int64, base := 10) {
        if i < 0 {
            i = -i;
            write("-");
        }

        write(cast(uint64) i, base);
    }

    fn write(i uint64, base := 10) {
        // TODO: validate the base.

        BUFFER_SIZE :: 21;
        buffer char[BUFFER_SIZE] = ---;

        ptr char* = chars_of_uint64(i, buffer + BUFFER_SIZE - 1, base);

        length := cast(uint)(buffer + BUFFER_SIZE) - cast(uint)ptr;
        write_buffer(ptr, length);
    }

    fn write(i int, base := 10) {
        write(cast(int64) i, base);
    }

    fn write(i uint, base := 10) {
        write(cast(uint64) i, base);
    }

    fn write(any Any) {
        write_any(any.value, any.type);
    }

    private fn write_any(value void*, type const Type*) {
        // TODO: replace with a switch statement once supported.
        if type.id == TypeId.CSTR {
            write(cast(cstr) value);
        }
        // Annoying but have to cast specitly to the right integer
        // size otherwise it won't be able to interpret the size right.
        else if type.id == TypeId.INT {
            write(*cast(int*) value);
        } else if type.id == TypeId.UINT {
            write(*cast(uint*) value);
        } else if type.id == TypeId.UINT8 {
            write(*cast(uint8*) value);
        } else if type.id == TypeId.UINT16 {
            write(*cast(uint16*) value);
        } else if type.id == TypeId.UINT32 {
            write(*cast(uint32*) value);
        } else if type.id == TypeId.UINT64 {
            write(*cast(uint64*) value);
        } else if type.id == TypeId.INT8 {
            write(*cast(int8*) value);
        } else if type.id == TypeId.INT16 {
            write(*cast(int16*) value);
        } else if type.id == TypeId.INT32 {
            write(*cast(int32*) value);
        } else if type.id == TypeId.INT64 {
            write(*cast(int64*) value);
        } else if type.id == TypeId.CHAR {
            write(*cast(char*) value);
        } else if type.is_pointer() {
            // TODO: abstract pointer printing out?
            // TODO: pad 0s.
            write("0x");
            write(cast(uint) cast(uint*) value, 16);
        } else if type.id == TypeId.ARRAY {
            array_info := type.array_info;
            write_array_like_type(value, array_info.element_type, array_info.length);
        } else if type.id == TypeId.BOOL {
            write(*cast(bool*) value);
        } else if type.id == TypeId.EMPTY_ARRAY_ELM {
            write("[ ]");
        } else if type.id == TypeId.F32 {
            write("printing floats not supported yet");
        } else if type.id == TypeId.F64 {
            write("printing floats not supported yet");
        } else if type.id == TypeId.SLICE {
            slice_length  := *cast(int*) value;
            slice_arr_ptr := value + sizeof(int);
            // We have the address of the pointer need the pointer itself.
            array void* = *cast(void**) slice_arr_ptr;
            
            write_array_like_type(array, type.element_type, slice_length);
        } else if type.id == TypeId.STRUCT {
            //if type.struct_info == typeof(String).struct_info {
            if type == typeof(String) {
                string := cast(String*) value;
                write_buffer(string.buffer, string.length);
                return;
            }
            
            write(type.struct_info.name);
            write("{ ");
            
            num_fields := type.struct_info.num_fields;
            loop i := 0; i < num_fields; i++ {
                field := type.struct_info.fields[i];
                
                write(field.name);
                write(":");
                field_value void* = value + field.offset_in_bytes;
                
                if field.type.is_string() {
                    write("\"");
                }
                if field.type.is_pointer() {
                    // See comment unrder write_array_like_type for explaination.
                    ptr_addr := cast(void**) field_value;
                    field_value = *ptr_addr;
                }
                write_any(field_value, field.type);
                
                if field.type.is_string() {
                    write("\"");
                }
                if i+1 != num_fields {
                    write(", ");
                }
            }
            
            write(" }");
        } else {
            write("do not know how to write type!");
        }
    }
    
    private fn write_array_like_type(array void*, elm_type Type*, length int) {
        write("[ ");
            
        elm_byte_size := elm_type.size_in_bytes;
        loop i := 0; i < length; i++ {
            offset_into_array void* = array + (i * elm_byte_size);
            if elm_type.is_string() {
                write("\"");
            }
            if elm_type.is_pointer() {
                // The offset into the array gives us an address of the element
                // which is typically what we want except for pointer types in
                // which case we want the pointer itself.
                ptr_addr := cast(void**) offset_into_array;
                offset_into_array = *ptr_addr;
            }
            write_any(offset_into_array, elm_type);
            if elm_type.is_string() {
                write("\"");
            }
            
            if i+1 != length {
                write(", ");
            }
        }
        
        write(" ]");
    }

    fn write(fmt cstr, args Any...) {
        length  := strlen(fmt);
        arg_idx := 0;
        loop i := 0; i < length; i++ {
            c := fmt[i];
            if c == '%' && arg_idx < args.length {
                if i+1 < length && fmt[i+1] == 's' {
                    write(args[arg_idx++]);
                    ++i;
                }
            } else {
                write(c);
            }
        }
    }

    // ----------------------------------------
    // writeln functions

    fn writeln(msg cstr) {
        write(msg, strlen(msg));
        write("\n", 1);
    }

    fn writeln(msg String*) {
        write(msg);
        write("\n", 1);
    }

    fn writeln(i int, base := 10) {
        write(cast(int64) i, base);
        write("\n", 1);
    }

    fn writeln(i uint, base := 10) {
        write(cast(uint64) i, base);
        write("\n", 1);
    }

    fn writeln(i int64, base := 10) {
        write(i);
        write("\n", 1);
    }

    fn writeln(i uint64, base := 10) {
        write(i, base);
        write("\n", 1);
    }

    fn writeln(b bool) {
        write(b);
        write("\n", 1);
    }

    fn writeln(c char) {
        write(c);
        write("\n", 1);
    }

    fn writeln(any Any) {
        write(any);
        write("\n", 1);
    }

    fn writeln(fmt cstr, args Any...) {
        write(fmt, args);
        write("\n", 1);
    }

    fn writeln() {
        write("\n", 1);
    }
}