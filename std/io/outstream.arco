import files.FileHandle;

/**
 * An output stream for writing to files, sockets, or
 * any streamable handle that is writeable.
 */
OutStream struct {
	
	// TODO: This handle should eventually be more abstract
	//       and be a any writable handle instead.
	handle FileHandle;

	fn OutStream(handle void*, auto_close := true)
		: handle(FileHandle{handle, auto_close}) {
	}

	// TODO: This stream should not write directly to the handle.
	//       In the future the stream should be abstracted in such
	//       a way that it writes to another stream such as a buffered
	//       output stream, which then writes to the handle.
	fn write(msg cstr, length int) {
		handle.write(msg, length);
	}

	fn write(msg cstr) {
		write(msg, strlen(msg));
	}

	fn write(msg String*) {
		write(msg.buffer, msg.length);
	}

	fn write(b bool) {
		if b {
			write("true");
		} else {
			write("false");
		}
	}

	fn write(c char) {
		write(&c, 1);
	}

	fn write(i int64) {
		if i < 0 {
			i = -i;
			write("-");
		}

		write(cast(uint64) i);
	}

	fn write(i uint64) {
		BUFFER_SIZE :: 21;
		buffer char[BUFFER_SIZE];

		ptr char* = chars_of_uint64(i, buffer + BUFFER_SIZE - 1, 10);

		length := cast(uint)(buffer + BUFFER_SIZE) - cast(uint)ptr;
		write(ptr, length);
	}

	fn write(i int) {
		write(cast(int64) i);
	}

	fn write(i uint) {
		write(cast(uint64) i);
	}

	// ----------------------------------------
	// writeln functions

	fn writeln(msg cstr) {
		write(msg, strlen(msg));
		write("\n", 1);
	}

	fn writeln(msg String*) {
		write(msg);
		write("\n", 1);
	}

	fn writeln(i int) {
		write(cast(int64) i);
		write("\n", 1);
	}

	fn writeln(i uint) {
		write(cast(uint64) i);
		write("\n", 1);
	}

	fn writeln(i int64) {
		write(i);
		write("\n", 1);
	}

	fn writeln(i uint64) {
		write(i);
		write("\n", 1);
	}

	fn writeln(b bool) {
		write(b);
		write("\n", 1);
	}

	fn writeln(c char) {
		write(c);
		write("\n", 1);
	}

	fn writeln() {
		write("\n", 1);
	}

	fn close() {
		handle.close();
	}
}