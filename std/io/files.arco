namespace files;
import win32;

import std.InStream;

// TODO: Will eventually want to replace with an enum!
//

FLAG_IN  :: 0x0001u;
FLAG_OUT :: 0x0002u;

/*
 * More than once open instance of the
 * file can be opened and accessed at
 * the same time.
 */
FLAG_SHARE :: 0x0004u;

/* Creates the file if it does not exist. */
FLAG_CREATE :: 0x0008u;

/*
 * Reads an entire file into a string.
 */
fn read(path cstr) String {
	
	// TODO: hacky: relying on obtaining the underlying
	// InStream from the BufferedStream. open should be
	// able to specify which stream you want.

	stream := open(path, FLAG_IN);
	size   := stream.in.get_size();
	buffer := new char[size + 1];
	
	stream.in.read(buffer, size);
	
	// Null terminating
	buffer[size] = '\0';
	return String{ buffer, size, false };
}

/*
 * Returns true if the file system has a file or
 * folder at the given path.
 */
fn exists(path cstr) bool {
	attribs uint32 = win32.GetFileAttributesA(path);
	return attribs != win32.INVALID_FILE_ATTRIBUTES;
}

fn open(path cstr, flags uint) BufferedStream {
	access_flags uint32 = 0;
	share_flags  uint32 = 0;
	create_flags uint32 = 0;

	if flags == 0 {
		access_flags = win32.GENERIC_ALL;
	}

	if (flags & FLAG_IN) != 0 {
		access_flags |= win32.GENERIC_READ;
	}

	if (flags & FLAG_OUT) != 0 {
		access_flags |= win32.GENERIC_WRITE;
	}

	if (flags & FLAG_SHARE) != 0 {
		share_flags |= win32.FILE_SHARE_READ;
	}

	if (flags & FLAG_CREATE) != 0 {
		create_flags |= win32.CREATE_NEW;
	} else {
		create_flags |= win32.OPEN_EXISTING;
	}

	handle void* = win32.CreateFileA(path,
	                                 access_flags,
								     share_flags,
								     null,
								     create_flags,
								     win32.FILE_ATTRIBUTE_NORMAL,
								     null);

	if handle == win32.INVALID_HANDLE_VALUE {
		// TODO: properly handle the error once supported.
		panic("Failed to open filestream!");
	}
	
	// TODO: What if they want a stream to write?
	return BufferedStream{ handle };
}