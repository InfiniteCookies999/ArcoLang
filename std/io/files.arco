namespace files;
import win32;

// TODO: should support a Path struct for minipulating file
// paths and allow the functions to be compatible.

// TODO: directory iterating but need iterators in the lang first.

// TODO: file renaming.

/*
 * Flags that indicate how to open a file for
 * reading and writing.
 */
IOFlag enum : uint32 {
	IN     :: 0x0001;
	OUT    :: 0x0002;	

	/*
	 * More than once open instance of the
	 * file can be opened and accessed at
	 * the same time.
	 */
	SHARE  :: 0x0004;
	
	/* Creates the file if it does not exist. */
	CREATE :: 0x0008;
}

/*
 * A basic writable object for interfacing directly
 * with system files. This object may read and write
 * chunks of pre-allocated bytes to the file.
 */
FileHandle struct {
	
	handle     void*;
	auto_close bool;
	
	fn FileHandle(handle void*, auto_close := true) {
		this.handle     = handle;
		this.auto_close = auto_close;
	}
	
	fn ~FileHandle() {
		if auto_close {
			close();
		}
	}
	
	fn read(buffer char*, length int) int {
		// TODO: make sure the stream is still open.
		
		number_of_bytes_read uint32;
		win32.ReadFile(handle, buffer, cast(uint32) length, &number_of_bytes_read, null);
		return cast(int) number_of_bytes_read;
	}
	
	fn write(buffer cstr, length int) int {
		// TODO: make sure the stream is still open.
	
		number_of_bytes_written uint32;
		win32.WriteFile(handle, buffer, cast(uint32) length, &number_of_bytes_written, null);
		return cast(int) number_of_bytes_written;
	}
	
	fn get_size() int {
		size uint32 = win32.GetFileSize(handle, null);
		return cast(int) size;
	}
	
	fn close() {
		win32.CloseHandle(handle);
		handle = null;
	}
}

/*
 * Reads an entire file into a string.
 */
fn read(path cstr) String {
	
	stream := open(path, IOFlag.IN);
	size   := stream.get_size();
	buffer := new char[size + 1];
	
	read_bytes := stream.read(buffer, size);
	if read_bytes != size {
		// TODO: proper error handling
		panic("Failed to read file");
	}

	// Null terminating
	buffer[size] = '\0';
	return String{ buffer, size, false };
}

/*
 * Reads an entire file into a string.
 */
fn read(path String*) String {
	return read(path.buffer);
}

/*
 * Returns true if the file system has a file or
 * folder at the given path.
 */
fn exists(path cstr) bool {
	attribs uint32 = win32.GetFileAttributesA(path);
	return attribs != win32.INVALID_FILE_ATTRIBUTES;
}

/*
 * Returns true if the file system has a file or
 * folder at the given path.
 */
fn exists(path String*) bool {
	return exists(path.buffer);
}

/*
 * Returns true if the file system has a file but
 * is not a directory at the given path.
 */
fn file_exists(path cstr) bool {
	attribs uint32 = win32.GetFileAttributesA(path);
	return attribs != win32.INVALID_FILE_ATTRIBUTES &&
	      (attribs &  win32.FILE_ATTRIBUTE_DIRECTORY) == 0;
}

/*
 * Returns true if the file system has a file but
 * is not a directory at the given path.
 */
fn file_exists(path String*) bool {
	return file_exists(path.buffer);
}

/*
 * Returns true if the file system has a directory
 * at the given path.
 */
fn directory_exists(path cstr) bool {
	attribs uint32 = win32.GetFileAttributesA(path);
	return attribs != win32.INVALID_FILE_ATTRIBUTES &&
	      (attribs &  win32.FILE_ATTRIBUTE_DIRECTORY) != 0;
}

/*
 * Returns true if the file system has a directory
 * at the given path.
 */
fn directory_exists(path String*) bool {
	return directory_exists(path.buffer);
}

/*
 * Creates the directory(s) at the given path. Returns
 * true if created.
 *
 * @Param mkparents if true it will also make the
 *                  necessary parent directories.
 */
fn mkdir(path cstr, mkparents := false) bool {
	// TODO: implement making parents.
	return win32.CreateDirectoryA(path, null) != 0;
}

/*
 * Creates the directory(s) at the given path. Returns
 * true if created.
 *
 * @Param mkparents if true it will also make the
 *                  necessary parent directories.
 */
fn mkdir(path String*, mkparents := false) bool {
	return mkdir(path.buffer);
}

/*
 * Deletes the file or directory if it exists.
 * Returns true if it succeeded.
 *
 * If deleting a directory the directory must be
 * empty.
 */
fn remove(path cstr) bool {
	attribs uint32 = win32.GetFileAttributesA(path);
	if attribs == win32.INVALID_FILE_ATTRIBUTES {
		return false;
	}
	if (attribs & win32.FILE_ATTRIBUTE_DIRECTORY) != 0 {
		return win32.RemoveDirectoryA(path) != 0;
	}
	return win32.DeleteFileA(path) != 0;
}

/*
 * Deletes the file or directory if it exists.
 * Returns true if it succeeded.
 *
 * If deleting a directory the directory must be
 * empty.
 */
fn remove(path String*) bool {
	return remove(path.buffer);
}

/*
 * Returns the last time the file was modified as a 64 bit
 * unsigned integer representing the amount of 100-nanosecond
 * intervals since January 1, 1601 (UTC).
 */
fn last_modified(path cstr) uint64 {
	// TODO: Proper error handling.

	handle := win32.CreateFileA(path,
	                            win32.GENERIC_ALL,
								win32.FILE_SHARE_READ,
								null,
								win32.OPEN_EXISTING,
								0,
								null);

	if handle == win32.INVALID_HANDLE_VALUE {
		panic("Could not get last modified time for path");
	}

	create_time, access_time, write_time uint64;
	if win32.GetFileTime(handle, &create_time, &access_time, &write_time) == 0 {
		panic("Could not get last modified time for path");
	}

	return write_time;
}

fn open(path cstr, flags IOFlag) FileHandle {
	access_flags uint32 = 0;
	share_flags  uint32 = 0;
	create_flags uint32 = 0;

	if flags == 0 {
		access_flags = win32.GENERIC_ALL;
	}

	if (flags & IOFlag.IN) != 0 {
		access_flags |= win32.GENERIC_READ;
	}

	if (flags & IOFlag.OUT) != 0 {
		access_flags |= win32.GENERIC_WRITE;
	}

	if (flags & IOFlag.SHARE) != 0 {
		share_flags |= win32.FILE_SHARE_READ;
	}

	if (flags & IOFlag.CREATE) != 0 {
		create_flags |= win32.CREATE_NEW;
	} else {
		create_flags |= win32.OPEN_EXISTING;
	}

	handle void* = win32.CreateFileA(path,
	                                 access_flags,
								     share_flags,
								     null,
								     create_flags,
								     win32.FILE_ATTRIBUTE_NORMAL,
								     null);

	if handle == win32.INVALID_HANDLE_VALUE {
		// TODO: properly handle the error once supported.
		panic("Failed to open filestream!");
	}
	
	return FileHandle{ handle };
}